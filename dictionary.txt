*** Variables ***

Each variable have an associated word which behaves like a regular variable,
that is, it pushes the address of the variable on the stack.

here            Memory offset pointing to the end of the dictionary. Creating
                a new entry places that entry HERE and then increases it
                accordingly.

current         Memory offset pointing to the last entry of the dictionary.

*** Builtin words ***

emit            ( c -- )        Emit character c to console.
bye             ( -- )          Quits interpreter.
.               ( n -- )        Print n in decimal representation.
.x              ( n -- )        Print n in hex representation.
execute         ( hi -- )       Execute from heap starting at offset hi.
: w t1 t2 ... ; ( -- )          Define word w and associate with code compiled
                                from tokens.
loadf fname     ( -- )          Reads file fname and interprets its contents as
                                if it was typed directly in the interpreter.
!               ( x a -- )      store value x in cell at address a.
@               ( a -- x )      fetch value x from cell at address a.
C!              ( x a -- )      store byte value x in cell at address a.
C@              ( a -- x )      fetch value x from cell at address a.
forget x        ( -- )          Remove latest entry named x from dict.
create x        ( -- )          Create entry named x, header only
allot           ( n -- )        Increase "here" variable by n.
regr r          ( -- n)         Put value of register r in n. r can be a single
                                register name (A, B, C) or a pair (BC, DE).
regw r          ( n -- )        Put n in register r.
+               ( x y -- z )    x + y => z
-               ( x y -- z )    x - y => z
*               ( x y -- z )    x * y => z
/               ( x y -- z )    x / y => z
lshift          ( x y -- z )    left shift of x by y places => z
rshift          ( x y -- z )    right shift of x by y places => z
call            ( a -- )        Set PC to a and execute code until the CPU has
                                halted. Note that the halting condition is
                                temporary. When the interpreter has fully moved
                                into z80, a RET will return from that call.
dup             ( n -- n n )    Duplicates TOS.

*** In core ***

variable x      ( -- )          Creates a new word x pointing to a 2 bytes cell.
?               ( -- )          Same as "@ ."
,               ( n -- )        Grow latest entry by 2 bytes and set those bytes
                                to value n.
C,              ( n -- )        Grow latest entry by 1 byte and set that byte to
                                value n.
splitb          ( n -- h l )    Split number n into hish and low bytes.

*** zasm (in zasm.fth) ***

This unit supplies word to emit binary upcode from mnemonics. Those mnemonics
follow these patterns:

No argument: The word, which corresponds to the z80 mnemonic, spits (using
"C,") the upcode. For example, "HALT," spits 0x76.

Regular argument(s): Upcode that follow a rgular pattern have their argument
"spec letter" as a prefix in the word. For example, "LD r, r'" is invoked with
the word "LDrr,". Arguments must be in the stack in *inverse* order (so that
in the code itself, they appear in an order that isn't mind-bending). For
example, "LD A, 42" is typed "A 42 LDrn,".

Special arguments: Some upcodes have some kind of "constant" arguments and map
to irregular upcodes. For example "ADD HL, ss". These have specifics words. For
example, "ADD HL, DE" is invoked as "DE ADDHLss,"

Not all upcodes are implemented yet. Look in zasm.fth.
